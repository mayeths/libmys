#!/usr/bin/env python3
VERSION="230207"

import sys
import argparse
import textwrap
import shutil
import math
import pathlib
import tempfile
from typing import Union

QUIET = False
def eprint(text, end='\n', force=False):
    global QUIET
    if force or not QUIET:
        print(text, end=end, file=sys.stderr)

class Slot:
    node_index: int
    socket_index: int
    numa_index: int
    core_index: int
    hwthread_index: int

    def __init__(self, node_index: int, socket_index: int, numa_index: int, core_index: int, hwthread_index: int):
        self.node_index = node_index
        self.socket_index = socket_index
        self.numa_index = numa_index
        self.core_index = core_index
        self.hwthread_index = hwthread_index

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        other: Slot = other
        if self.node_index != other.node_index:
            return False
        elif self.socket_index != other.socket_index:
            return False
        elif self.numa_index != other.numa_index:
            return False
        elif self.core_index != other.core_index:
            return False
        elif self.hwthread_index != other.hwthread_index:
            return False
        return True

    def __hash__(self) -> int:
        return hash((self.hwthread_index, self.core_index, self.numa_index, self.socket_index, self.node_index))

class Rank:
    id: int
    node_format: Union[str, None]
    node_index: Union[int, None]
    slots: Union[list[int], None]

    def __init__(self, id, node_format=None, node_index=None, slots=None):
        self.id = id
        self.node_format = node_format
        self.node_index = node_index
        self.slots = slots

    def __str__(self):
        node_name = self.get_node_name()
        if not self.slots:
            raise ValueError(f"rank {self.id} is not assigned to any core range on {node_name}")
        self.slots.sort()
        if len(self.slots) == 1:
            slot_str = f"{self.slots[0]}"
        elif Rank._is_sorted_index_continuous(self.slots):
            slot_str = f"{self.slots[0]}-{self.slots[-1]}"
        else:
            slot_str = f",".join(self.slots)
        return f"rank {self.id}={node_name} slot={slot_str}"

    def get_node_name(self):
        if self.node_format is None or self.node_index is None:
            raise ValueError(f"rank {self.id} is not assigned to any node {self.node_index}")
        node_name = self.node_format.format(self.node_index)
        if self.node_index < 0:
            eprint(f'[ERROR] rank {self.id} is assigned to negative node index {self.node_index}, causing node name "{node_name}"', force=True)
            exit(1)
        return node_name

    @staticmethod
    def _is_sorted_index_continuous(arr: list[int]):
        for i in range(1, len(arr)):
            if arr[i] - arr[i - 1] > 1:
                return False
        return True


class HardwareInfo:
    name_format: str
    sockets_per_node: int
    numas_per_node: int
    numas_per_socket: int
    cores_per_node: int
    cores_per_socket: int
    cores_per_numa: int
    hwthreads_per_core: int
    hwthreads_per_numa: int
    hwthreads_per_socket: int
    hwthreads_per_node: int


    def __init__(self, name_format: str, sockets_per_node: int, numas_per_socket: int, cores_per_numa: int, hwthreads_per_core: int):
        self.name_format = name_format

        self.sockets_per_node = sockets_per_node

        self.numas_per_socket = numas_per_socket
        self.numas_per_node = self.numas_per_socket * self.sockets_per_node

        self.cores_per_numa = cores_per_numa
        self.cores_per_socket = self.cores_per_numa * self.numas_per_socket
        self.cores_per_node = self.cores_per_numa * self.numas_per_node

        self.hwthreads_per_core = hwthreads_per_core
        self.hwthreads_per_numa = self.hwthreads_per_core * self.cores_per_numa
        self.hwthreads_per_socket = self.hwthreads_per_core * self.cores_per_socket
        self.hwthreads_per_node = self.hwthreads_per_core * self.cores_per_node


# Fingerprint is only correct for contiguous slot mapping
def print_fingerprint(hwinfo: HardwareInfo, ranks: list[Rank], target_node_index: int, symbols=["+", "-"], void_symbol="."):
    ranks = [rank for rank in ranks if rank.node_index == target_node_index]
    if not ranks:
        return
    core_ranks = [-1] * hwinfo.cores_per_node
    for i in range(len(ranks)):
        rank = ranks[i]
        for used in rank.slots:
            core_ranks[used] = i
    symbol_index = 0
    last_rank = 0
    node_name = ranks[0].get_node_name()
    digit = int(math.log10(hwinfo.cores_per_node)) + 1
    finger = "{node_name} {number:{digit}d} [".format(node_name=node_name, digit=digit, number=0)
    for i in range(len(core_ranks)):
        core_rank = core_ranks[i]
        if core_rank == -1:
            finger += void_symbol
        elif core_rank != last_rank:
            symbol_index = (symbol_index + 1) % len(symbols)
            finger += symbols[symbol_index]
            last_rank = core_rank
        else:
            finger += symbols[symbol_index]
        if i == hwinfo.cores_per_node - 1:
            finger += "] {number:{digit}d}".format(digit=digit, number=hwinfo.cores_per_node)
        elif i % hwinfo.cores_per_numa == hwinfo.cores_per_numa - 1:
            finger += "] {n1:{digit}d}\n{node_name} {n2:{digit}d} [".format(node_name=node_name, digit=digit, n1=i, n2=i+1)
    eprint(finger)


def main():
    global QUIET
    terminal_width = shutil.get_terminal_size((80, 20))[0]
    parser = argparse.ArgumentParser(
        prog='rankgen',
        description=f'Genrate rankfile or command line arguments by specified distribution (version {VERSION})\n',
        epilog='Example: %(prog)s --fingerprint=all --name-format="bn{:03d}" --last-node-index=108 2 24 10',
        add_help=False,
        usage='%(prog)s <num_node> <num_rank> <thread_per_rank> [OPTIONS]',
        formatter_class=lambda prog: argparse.ArgumentDefaultsHelpFormatter(prog, max_help_position=terminal_width)
    )
    parser.add_argument('num_node', type=int, help=f"Number of node to use")
    parser.add_argument('num_rank', type=int, help=f"Number of ranks")
    parser.add_argument('thread_per_rank', type=int, default=1, help=f"Number of threads per rank")
    # metavar='' for removing dest variable from help text
    hwinfoArgs = parser.add_argument_group('Hardware information arguments')
    hwinfoArgs.add_argument('--name-format', dest='name_format', default="cn{:03d}", type=str, help=f"Node name format in python formatting syntax", metavar='')
    hwinfoArgs.add_argument('--sockets-per-node', dest='sockets_per_node', default=2, type=int, help=f"Sockets per node", metavar='')
    hwinfoArgs.add_argument('--numas-per-socket', dest='numas_per_socket', default=2, type=int, help=f"NUMAs per socket", metavar='')
    hwinfoArgs.add_argument('--cores-per-numa', dest='cores_per_numa', default=32, type=int, help=f"Cores per numa", metavar='')
    # hwinfoArgs.add_argument('--hwthreads-per-core', dest='hwthreads_per_core', default=1, type=int, help=f"HWThreads per core", metavar='')
    generatorArgs = parser.add_argument_group('generator arguments')
    generatorArgs.add_argument('-o', dest='outfile', default="<stdout>", type=str, help=f"Write output to file", metavar='')
    generatorArgs.add_argument('-t', '--temp', dest='use_tempfile', action='store_const', const=True, default=False, help="Write output to temp file and print filename", metavar='')
    generatorArgs.set_defaults(left_most_cores=False)
    generatorArgs.set_defaults(no_fingerprint=False)
    generatorArgs.add_argument('--left-most-cores', dest='left_most_cores', action='store_const', const=True, help="Use left-most cores in NUMA", metavar='')
    generatorArgs.add_argument('--first-node-index', dest='first_node_index', default=101, type=int, help="Inclusive node start index", metavar='')
    generatorArgs.add_argument('--last-node-index', dest='last_node_index', type=int, help="Inclusive node end index", metavar='')
    generatorArgs.add_argument('--fingerprint', dest='fingerprint', default="first", choices=['first', 'all', 'no'], help="Display first/all/no fingerprint of node", metavar='')
    parser.add_argument('-q', '--quiet', dest='quiet', action='store_const', const=True, default=False, help="Don't print information", metavar='')
    parser.add_argument('-v', '--version', action='version', version=f'{VERSION}', help="Show version number and exit")
    parser.add_argument('-h', '--help', action='help', help=f"Show this help message and exit")

    args = parser.parse_args()
    num_node = args.num_node
    num_rank = args.num_rank
    thread_per_rank = args.thread_per_rank
    hwinfo = HardwareInfo(args.name_format, args.sockets_per_node, args.numas_per_socket, args.cores_per_numa, 1)
    outfile = args.outfile
    use_tempfile = args.use_tempfile
    left_most_cores = args.left_most_cores
    first_node_index = args.first_node_index
    last_node_index = args.last_node_index
    fingerprint = args.fingerprint
    QUIET = args.quiet

    # NOTE: Currently, slot is core TODO: support --slot=hwthread or --slot=core
    rank_per_node = num_rank // num_node
    ranks_per_numa = rank_per_node // hwinfo.numas_per_node
    slots_per_numa = ranks_per_numa * thread_per_rank
    slots_per_socket = slots_per_numa * hwinfo.numas_per_socket
    slots_per_node = slots_per_numa * hwinfo.numas_per_node
    assert rank_per_node % hwinfo.numas_per_node == 0, f"Requested rank per node ({rank_per_node}) cannot be split to numa ({hwinfo.numas_per_node}) equally"
    assert slots_per_numa <= hwinfo.cores_per_numa, f"{num_node} nodes, {num_rank} procs and {thread_per_rank} threads need {slots_per_numa} slots per numa but only {hwinfo.cores_per_numa} cores per numa"

    nranks = rank_per_node * num_node
    ranks = [Rank(i) for i in range(nranks)]
    if last_node_index is None:
        last_node_index = first_node_index + num_node - 1
    else:
        first_node_index = last_node_index - num_node + 1

    for i in range(nranks):
        rank = ranks[i]
        global_slot_start = i * thread_per_rank
        numa_index = (global_slot_start // slots_per_numa) % hwinfo.numas_per_node # which numa in node
        slot_start_index = numa_index * hwinfo.cores_per_numa + (i % ranks_per_numa) * thread_per_rank
        slot_stop_index = slot_start_index + thread_per_rank - 1
        if not left_most_cores:
            offset = hwinfo.cores_per_numa - slots_per_numa
            slot_start_index = offset + slot_start_index
            slot_stop_index = offset + slot_stop_index
        rank.slots = [i for i in range(slot_start_index, slot_stop_index+1)]
        rank.node_format = hwinfo.name_format
        rank.node_index = first_node_index + (global_slot_start // slots_per_node) # which node

    eprint(f"{parser.prog}: {parser.description}")
    eprint(f"=== Node Information")
    eprint(f"name prefix: {hwinfo.name_format}")
    eprint(f"sockets per node: {hwinfo.sockets_per_node}")
    eprint(f"numas per node: {hwinfo.numas_per_node}")
    eprint(f"cores per node: {hwinfo.cores_per_node}")
    eprint(f"")
    eprint(f"=== Generator Information")
    eprint(f"Number of node: {num_node}")
    eprint(f"Number of rank (per node): {rank_per_node}")
    eprint(f"Number of thread (per rank): {thread_per_rank}")
    eprint(f"Output to {outfile}")
    eprint(f"")

    content = "\n".join([str(rank) for rank in ranks])
    if use_tempfile:
        with tempfile.NamedTemporaryFile(mode="w", delete=True) as tmp:
            tmp.write(content)
            print(tmp.name)
    elif outfile == "<stdout>":
        eprint(f"=== Content generated to <stdout>:")
        print(content)
        eprint(f"")
    else:
        pathlib.Path(outfile).parent.mkdir(parents=True, exist_ok=True)
        with open(outfile, "w") as f:
            f.write(content)
    if fingerprint == "first":
        eprint(f"=== Fingerprint of first node")
        print_fingerprint(hwinfo, ranks, first_node_index)
    elif fingerprint == "all":
        eprint(f"=== Fingerprint of all {num_node} nodes")
        for i in range(first_node_index, last_node_index+1):
            print_fingerprint(hwinfo, ranks, i)

if __name__ == '__main__':
    main()
