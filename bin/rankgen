#!/usr/bin/env python3
VERSION="230207"

import sys
import argparse
import shutil
import math
import pathlib
import tempfile
import functools
from typing import Union, List

QUIET = False
def eprint(text, end='\n', force=False):
    global QUIET
    if force or not QUIET:
        print(text, end=end, file=sys.stderr)

def eexit(code, text=None, end='\n'):
    if text is not None:
        eprint('[ERROR] ' + text, end=end, force=True)
    exit(code)

@functools.total_ordering
class Slot:
    node_index: int
    region_index: int # in node
    start: int # in node
    stop: int # in node

    def __init__(self, node_index: int, region_index: int, slot_start: int, slot_stop: int) -> None:
        self.node_index = node_index
        self.region_index = region_index
        self.start = slot_start
        self.stop = slot_stop

    def __eq__(self, other) -> bool:
        if not isinstance(other, Slot):
            return False
        return ((self.node_index, self.region_index, self.start, self.stop) ==
                (other.node_index, self.region_index, other.start, other.stop))

    def __lt__(self, other) -> bool:
        if not isinstance(other, Slot):
            return False
        return ((self.node_index, self.region_index, self.start, self.stop) <
                (other.node_index, self.region_index, other.start, other.stop))

class RecorderAction(argparse.Action):
    named_record = {}
    unnamed_record = []
    def __call__(self, parser, namespace, values, option_string=None):
        if option_string is not None:
            RecorderAction.named_record[option_string] = values
        else:
            RecorderAction.unnamed_record.append(values)
        setattr(namespace, self.dest, values)

class HardwareInfo:
    name_format: str
    sockets_per_node: int
    numas_per_node: int
    numas_per_socket: int
    cores_per_node: int
    cores_per_socket: int
    cores_per_numa: int
    # hwthreads_per_core: int
    # hwthreads_per_numa: int
    # hwthreads_per_socket: int
    # hwthreads_per_node: int


    def __init__(self, name_format: str, sockets_per_node: int, numas_per_socket: int, cores_per_numa: int):
        self.name_format = name_format

        self.sockets_per_node = sockets_per_node

        self.numas_per_socket = numas_per_socket
        self.numas_per_node = self.numas_per_socket * self.sockets_per_node

        self.cores_per_numa = cores_per_numa
        self.cores_per_socket = self.cores_per_numa * self.numas_per_socket
        self.cores_per_node = self.cores_per_numa * self.numas_per_node

        # self.hwthreads_per_core = hwthreads_per_core
        # self.hwthreads_per_numa = self.hwthreads_per_core * self.cores_per_numa
        # self.hwthreads_per_socket = self.hwthreads_per_core * self.cores_per_socket
        # self.hwthreads_per_node = self.hwthreads_per_core * self.cores_per_node

    @staticmethod
    def generate_node_name(name_format: str, index: int):
        return name_format.format(index)

class Rank:
    id: int
    node_format: Union[str, None]
    node_index: Union[int, None]
    slots: Union[list[int], None]

    def __init__(self, id, node_format=None, node_index=None, slots=None):
        self.id = id
        self.node_format = node_format
        self.node_index = node_index
        self.slots = slots

    def __str__(self):
        node_name = self.get_node_name()
        if not self.slots:
            raise ValueError(f"rank {self.id} is not assigned to any core range on {node_name}")
        self.slots.sort()
        if len(self.slots) == 1:
            slot_str = f"{self.slots[0]}"
        elif Rank._is_sorted_index_continuous(self.slots):
            slot_str = f"{self.slots[0]}-{self.slots[-1]}"
        else:
            slot_str = f",".join(self.slots)
        return f"rank {self.id}={node_name} slot={slot_str}"

    def get_node_name(self):
        if self.node_format is None or self.node_index is None:
            raise ValueError(f"rank {self.id} is not assigned to any node {self.node_index}")
        node_name = HardwareInfo.generate_node_name(self.node_format, self.node_index)
        if self.node_index < 0:
            eexit(1, f'rank {self.id} is assigned to negative node index {self.node_index}, causing node name "{node_name}"')
        return node_name

    @staticmethod
    def _is_sorted_index_continuous(arr: list[int]):
        for i in range(1, len(arr)):
            if arr[i] - arr[i - 1] > 1:
                return False
        return True


# Fingerprint is only correct for contiguous slot mapping
def print_fingerprint(hwinfo: HardwareInfo, ranks: list[Rank], region: str,
# def print_fingerprint(hwinfo: HardwareInfo, region: str, used_cores: List[int],
                      target_node_index: int, symbols=["+", "-"], void_symbol="."):
    if region == "numa":
        cores_per_region = hwinfo.cores_per_numa
    elif region == "socket":
        cores_per_region = hwinfo.cores_per_socket
    else:
        cores_per_region = hwinfo.cores_per_node
    
    ranks = [rank for rank in ranks if rank.node_index == target_node_index]
    if not ranks:
        return
    core_to_ranks = [-1] * hwinfo.cores_per_node
    for i in range(len(ranks)):
        rank = ranks[i]
        for core in rank.slots:
            core_to_ranks[core] = i

    result = ""
    symbol_index = 0
    last_rank = 0
    for i in range(hwinfo.cores_per_node):
        if i % cores_per_region == 0:
            result += "|"
        rank = core_to_ranks[i]
        if rank == -1:
            result += void_symbol
        elif rank != last_rank:
            symbol_index = (symbol_index + 1) % len(symbols)
            result += symbols[symbol_index]
            last_rank = rank
        else:
            result += symbols[symbol_index]
    result += "|"
    eprint(result)


def fill_ranks(hwinfo: HardwareInfo, region: str, left_most_cores: bool,
                 enable_imbalance: bool, first_node_index: int, last_node_index: int,
                 num_node: int, num_rank: int, threads_per_rank: int):
    if region == "numa":
        regions_per_node = hwinfo.numas_per_node
        cores_per_region = hwinfo.cores_per_numa
    elif region == "socket":
        regions_per_node = hwinfo.sockets_per_node
        cores_per_region = hwinfo.cores_per_socket
    elif region == "node":
        regions_per_node = 1
        cores_per_region = hwinfo.cores_per_node

    num_region = regions_per_node * num_node
    ranks_per_region = num_rank // (regions_per_node * num_node)
    ranks_per_node = ranks_per_region * regions_per_node
    ranks_tail = num_rank - ranks_per_node * num_node

    slots_per_region = ranks_per_region * threads_per_rank
    slots_per_node = slots_per_region * regions_per_node

    first_node_name = HardwareInfo.generate_node_name(hwinfo.name_format, first_node_index)
    last_node_name = HardwareInfo.generate_node_name(hwinfo.name_format, last_node_index)

    # Check if requested slot is too many for node. We first assert node-wise for clear
    max_num_node = last_node_index - first_node_index + 1
    if num_node > max_num_node:
        eexit(1, f"Requested {num_node} nodes but "+
                 f"node [{first_node_name}, {last_node_name}] is {max_num_node} nodes only.")

    num_slots = num_rank * threads_per_rank
    max_slot = num_node * hwinfo.cores_per_node
    # Check if requested slot is too many for node first. (for clear information)
    if num_slots > max_slot:
        eexit(1, f"Requested {num_slots} cores but up to "
                +f"{max_slot} cores are allocatable on node [{first_node_name}, {last_node_name}].")
    # Check if requested slot is too many for region.
    if ranks_tail == 0:
        # Ideal distribution. Use slots_per_region to detect if too many
        if slots_per_region > cores_per_region:
            eexit(1, f"Requested {num_slots} cores ({slots_per_region} per {region}) but up to"
                    +f'{cores_per_region} cores per {region} only. '
                    +f'Maybe you want "--align=node"?')
    else:
        # Check if imbalanced and no enable_imbalance
        if not enable_imbalance:
            # Ask for explicit --imbalance
            eexit(1, f'Cannot split {num_rank} ranks (with {threads_per_rank} threads) to {region} equally '
                    +f'({cores_per_region} cores per {region}). Maybe you want "--align=node" or "--imbalance"?')
        if slots_per_region > cores_per_region:
            # For example, 1 rank with 33 threads on 2 sockets 4 numas 128 cores machine (32 cores per numa).
            eexit(1, f'{num_rank} ranks with {threads_per_rank} threads are imbalanced and too many '
                    +f'for {region} ({slots_per_region} but {cores_per_region} cores per {region} only). '
                    +f'Maybe you want "--align=node"?')

    slots: List[Slot] = []

    for i in range(num_rank):
        # Distribute by user specified nodes first. For example, user specified 2 node and 2 ranks,
        # We should put each rank on different node
        node_index = i % num_node # global
        region_index = (i % num_region) // num_node # in node
        region_index_g = node_index * regions_per_node + region_index # global
        inner_index = i // num_region # in region
        if left_most_cores:
            slot_start = region_index * cores_per_region + inner_index * threads_per_rank
            slot_stop = slot_start + threads_per_rank - 1
        else:
            slot_stop = (region_index + 1) * cores_per_region - 1 - inner_index * threads_per_rank
            slot_start = slot_stop - threads_per_rank + 1
        slot = Slot(first_node_index + node_index, region_index, slot_start, slot_stop)
        slots.append(slot)

    slots.sort()
    ranks = []

    for i in range(num_rank):
        slot = slots[i]
        core_list = [i for i in range(slot.start, slot.stop+1)]
        rank = Rank(i, hwinfo.name_format, slot.node_index, core_list)

        if slot.node_index > last_node_index:
            eexit(1, f'Invalid {str(rank)}. Out of range [{first_node_name}, {last_node_name}]')

        region_ok = slot.region_index >= 0 and slot.region_index < regions_per_node
        core_list_b1 = slot.region_index * cores_per_region
        core_list_b2 = (slot.region_index + 1) * cores_per_region - 1
        core_list_ok = slot.start >= core_list_b1 and slot.stop <= core_list_b2
        if not region_ok or not core_list_ok:
            eexit(1, f'Invalid {str(rank)}. Out of {region} {slot.region_index}: [{core_list_b1}, {core_list_b2}]')

        ranks.append(rank)

    return ranks


def main():
    global QUIET
    terminal_width = shutil.get_terminal_size((80, 20))[0]
    parser = argparse.ArgumentParser(
        prog='rankgen',
        description=f'Genrate rankfile or command line arguments by specified distribution (version {VERSION})\n',
        epilog='Example: %(prog)s --finger=all --name="bn{:03d}" --last=108 2 24 10',
        add_help=False,
        usage='%(prog)s [OPTIONS] <num_node> <num_rank> <threads_per_rank>',
        formatter_class=lambda prog: argparse.ArgumentDefaultsHelpFormatter(prog, max_help_position=terminal_width)
    )
    parser.add_argument('num_node', type=int, help=f"Number of node to use")
    parser.add_argument('num_rank', type=int, help=f"Number of ranks")
    parser.add_argument('threads_per_rank', type=int, default=1, help=f"Number of threads per rank")
    # metavar='' for removing dest variable from help text
    hwinfoArgs = parser.add_argument_group('Hardware information arguments')
    hwinfoArgs.add_argument('--name', dest='name', default="cn{:03d}", type=str, help=f"Node name format in python formatting syntax", metavar='')
    hwinfoArgs.add_argument('--first', dest='first', action=RecorderAction, default=101, type=int, help="Inclusive node start index", metavar='')
    hwinfoArgs.add_argument('--last', dest='last', action=RecorderAction, type=int, help="Inclusive node end index", metavar='')
    hwinfoArgs.add_argument('--sockets-per-node', dest='sockets_per_node', default=2, type=int, help=f"Sockets per node", metavar='')
    hwinfoArgs.add_argument('--numas-per-socket', dest='numas_per_socket', default=2, type=int, help=f"Numas per socket", metavar='')
    hwinfoArgs.add_argument('--cores-per-numa', dest='cores_per_numa', default=32, type=int, help=f"Cores per numa", metavar='')
    # TODO: Support hwthread
    # hwinfoArgs.add_argument('--hwthreads-per-core', dest='hwthreads_per_core', default=1, type=int, help=f"HWThreads per core", metavar='')
    generatorArgs = parser.add_argument_group('generator arguments')
    generatorArgs.add_argument('-o', dest='outfile', default="<stdout>", type=str, help=f"Write output to file", metavar='')
    generatorArgs.add_argument('-t', '--temp', dest='use_tempfile', action='store_const', const=True, default=False, help="Write output to temp file and print filename", metavar='')
    generatorArgs.set_defaults(left_most_cores=False)
    generatorArgs.set_defaults(no_fingerprint=False)
    generatorArgs.add_argument('--align', dest='region', default='numa', choices=['numa', 'socket', 'node'], help="Align ranks to the numa/socket/node region", metavar='')
    generatorArgs.add_argument('--imbalance', dest='imbalance', action='store_const', const=True, default=False, help="Allow imbalancing over regions", metavar='')
    generatorArgs.add_argument('--left', dest='left_most_cores', action='store_const', const=True, help="Use left-most cores of the region", metavar='')
    generatorArgs.add_argument('--finger', dest='fingerprint', default="first", choices=['first', 'all', 'no'], help="Display first/all/no fingerprint of node", metavar='')
    parser.add_argument('-q', '--quiet', dest='quiet', action='store_const', const=True, default=False, help="Don't print information", metavar='')
    parser.add_argument('-v', '--version', action='version', version=f'{VERSION}', help="Show version number and exit")
    parser.add_argument('-h', '--help', action='help', help=f"Show this help message and exit")

    args = parser.parse_args()
    num_node = args.num_node
    num_rank = args.num_rank
    threads_per_rank = args.threads_per_rank
    hwinfo = HardwareInfo(args.name, args.sockets_per_node, args.numas_per_socket, args.cores_per_numa)
    outfile = args.outfile
    use_tempfile = args.use_tempfile
    left_most_cores = args.left_most_cores
    region = args.region
    imbalance = args.imbalance
    fingerprint = args.fingerprint
    QUIET = args.quiet

    # TODO: Check arguments are positive int
    # if imbalance:
    #     eexit(1, f"imbalance not implemented.")

    if "--last" not in RecorderAction.named_record:
        first_node_index = args.first
        last_node_index = first_node_index + num_node - 1
        if num_node == 1:
            node_range_intro = f"{first_node_index}"
        else:
            node_range_intro = f"{first_node_index} to ..."
    else: #"--last" in RecorderAction.named_record
        if "--first" not in RecorderAction.named_record:
            last_node_index = args.last
            first_node_index = last_node_index - num_node + 1
            if num_node == 1:
                node_range_intro = f"{last_node_index}"
            else:
                node_range_intro = f"... to {last_node_index}"
        else: #"--first" in RecorderAction.named_record
            first_node_index = args.first
            last_node_index = args.last
            if first_node_index == last_node_index:
                node_range_intro = f"{first_node_index}"
            else:
                node_range_intro = f"{first_node_index} to {last_node_index}"

    ranks = fill_ranks(hwinfo, region, left_most_cores,
               imbalance, first_node_index, last_node_index,
               num_node, num_rank, threads_per_rank)

    eprint(f"{parser.prog}: {parser.description}")
    eprint(f"=== Node Information")
    eprint(f"Name format: {hwinfo.name_format}")
    eprint(f"Valid index: {node_range_intro}")
    eprint(f"Sockets per node: {hwinfo.sockets_per_node}")
    eprint(f"Numas per node: {hwinfo.numas_per_node}")
    eprint(f"Cores per node: {hwinfo.cores_per_node}")
    eprint(f"")
    eprint(f"=== Generator Information")
    if num_node == 1:
        eprint(f"Number of node: 1 ({ranks[0].get_node_name()})")
    else:
        eprint(f"Number of node: {num_node} ({ranks[0].get_node_name()} to {ranks[-1].get_node_name()})")
    eprint(f"Number of rank: {num_rank} ({num_rank // num_node} per node)")
    eprint(f"Number of thread: {threads_per_rank} per rank")
    eprint(f"Total cores required: {num_rank * threads_per_rank}")
    boundary = "left" if left_most_cores else "right"
    imbalance_message = " Imbalance enabled." if imbalance else ""
    eprint(f"Ranks are aligned to {boundary} most of {region}.{imbalance_message}")
    eprint(f"")

    content = "\n".join([str(rank) for rank in ranks])
    if use_tempfile:
        with tempfile.NamedTemporaryFile(mode="w", delete=True) as tmp:
            tmp.write(content)
            print(tmp.name)
    elif outfile == "<stdout>":
        eprint(f"=== Content generated to <stdout>:")
        print(content)
        eprint(f"")
    else:
        pathlib.Path(outfile).parent.mkdir(parents=True, exist_ok=True)
        with open(outfile, "w") as f:
            f.write(content)
    if fingerprint == "first":
        eprint(f"=== Fingerprint of first node")
        print_fingerprint(hwinfo, ranks, region, first_node_index)
    elif fingerprint == "all":
        eprint(f"=== Fingerprint of all {num_node} nodes")
        for i in range(first_node_index, first_node_index + num_node):
            print_fingerprint(hwinfo, ranks, region, i)

if __name__ == '__main__':
    main()
