#!/usr/bin/env python3
VERSION="230207"

import sys
import argparse
import shutil
import math
import pathlib
import tempfile
from typing import Union, List

QUIET = False
def eprint(text, end='\n', force=False):
    global QUIET
    if force or not QUIET:
        print(text, end=end, file=sys.stderr)

def eexit(code, text=None, end='\n'):
    if text is not None:
        eprint('[ERROR] ' + text, end=end, force=True)
    exit(code)

class RecorderAction(argparse.Action):
    named_record = {}
    unnamed_record = []
    def __call__(self, parser, namespace, values, option_string=None):
        if option_string is not None:
            RecorderAction.named_record[option_string] = values
        else:
            RecorderAction.unnamed_record.append(values)
        setattr(namespace, self.dest, values)

class Rank:
    id: int
    node_format: Union[str, None]
    node_index: Union[int, None]
    slots: Union[list[int], None]

    def __init__(self, id, node_format=None, node_index=None, slots=None):
        self.id = id
        self.node_format = node_format
        self.node_index = node_index
        self.slots = slots

    def __str__(self):
        node_name = self.get_node_name()
        if not self.slots:
            raise ValueError(f"rank {self.id} is not assigned to any core range on {node_name}")
        self.slots.sort()
        if len(self.slots) == 1:
            slot_str = f"{self.slots[0]}"
        elif Rank._is_sorted_index_continuous(self.slots):
            slot_str = f"{self.slots[0]}-{self.slots[-1]}"
        else:
            slot_str = f",".join(self.slots)
        return f"rank {self.id}={node_name} slot={slot_str}"

    def get_node_name(self):
        if self.node_format is None or self.node_index is None:
            raise ValueError(f"rank {self.id} is not assigned to any node {self.node_index}")
        node_name = self.node_format.format(self.node_index)
        if self.node_index < 0:
            eexit(1, f'rank {self.id} is assigned to negative node index {self.node_index}, causing node name "{node_name}"')
        return node_name

    @staticmethod
    def _is_sorted_index_continuous(arr: list[int]):
        for i in range(1, len(arr)):
            if arr[i] - arr[i - 1] > 1:
                return False
        return True


class HardwareInfo:
    name_format: str
    sockets_per_node: int
    numas_per_node: int
    numas_per_socket: int
    cores_per_node: int
    cores_per_socket: int
    cores_per_numa: int
    hwthreads_per_core: int
    hwthreads_per_numa: int
    hwthreads_per_socket: int
    hwthreads_per_node: int


    def __init__(self, name_format: str, sockets_per_node: int, numas_per_socket: int, cores_per_numa: int, hwthreads_per_core: int):
        self.name_format = name_format

        self.sockets_per_node = sockets_per_node

        self.numas_per_socket = numas_per_socket
        self.numas_per_node = self.numas_per_socket * self.sockets_per_node

        self.cores_per_numa = cores_per_numa
        self.cores_per_socket = self.cores_per_numa * self.numas_per_socket
        self.cores_per_node = self.cores_per_numa * self.numas_per_node

        self.hwthreads_per_core = hwthreads_per_core
        self.hwthreads_per_numa = self.hwthreads_per_core * self.cores_per_numa
        self.hwthreads_per_socket = self.hwthreads_per_core * self.cores_per_socket
        self.hwthreads_per_node = self.hwthreads_per_core * self.cores_per_node


# Fingerprint is only correct for contiguous slot mapping
def print_fingerprint(hwinfo: HardwareInfo, ranks: list[Rank], align: str,
                      target_node_index: int, symbols=["+", "-"], void_symbol="."):
    ranks = [rank for rank in ranks if rank.node_index == target_node_index]
    if not ranks:
        return
    core_ranks = [-1] * hwinfo.cores_per_node
    for i in range(len(ranks)):
        rank = ranks[i]
        for used in rank.slots:
            core_ranks[used] = i
    symbol_index = 0
    last_rank = 0
    node_name = ranks[0].get_node_name()
    finger = "{node_name} |".format(node_name=node_name)
    for i in range(len(core_ranks)):
        core_rank = core_ranks[i]
        if core_rank == -1:
            finger += void_symbol
        elif core_rank != last_rank:
            symbol_index = (symbol_index + 1) % len(symbols)
            finger += symbols[symbol_index]
            last_rank = core_rank
        else:
            finger += symbols[symbol_index]
        total_end = i == hwinfo.cores_per_node - 1
        node_end = i % hwinfo.cores_per_node == hwinfo.cores_per_node - 1
        socket_end = align == "socket" and i % hwinfo.cores_per_socket == hwinfo.cores_per_socket - 1
        numa_end = align == "numa" and i % hwinfo.cores_per_numa == hwinfo.cores_per_numa - 1
        if total_end:
            finger += "|"
        elif node_end:
            finger += "| \n{node_name} |".format(node_name=node_name)
            symbol_index = 0
            last_rank = core_rank + 1
        elif socket_end:
            finger += "|"
            symbol_index = 0
            last_rank = core_rank + 1
        elif numa_end:
            finger += "|"
            symbol_index = 0
            last_rank = core_rank + 1
    eprint(finger)

def aligned_fill(ranks: List[Rank], hwinfo: HardwareInfo, align: str, left_most_cores: bool,
                 num_rank: int, first_node_index: int, last_node_index: int,
                 ranks_per_node: int, threads_per_rank: int, num_node: int):
    if align == "numa":
        regions_per_node = hwinfo.numas_per_node
        cores_per_region = hwinfo.cores_per_numa
    elif align == "socket":
        regions_per_node = hwinfo.sockets_per_node
        cores_per_region = hwinfo.cores_per_socket
    elif align == "node":
        regions_per_node = 1
        cores_per_region = hwinfo.cores_per_node
    ranks_per_region = ranks_per_node // regions_per_node
    slots_per_region = ranks_per_region * threads_per_rank
    slots_per_node = slots_per_region * regions_per_node

    # Check if requested slot is too many for node. We first output assert of node for beauty
    if num_rank * threads_per_rank > num_node * hwinfo.cores_per_node:
        eexit(1, f"{num_rank} ranks with {threads_per_rank} threads are too many "
                +f"for {num_node} node ({hwinfo.cores_per_node} cores per node)")
    # Check if requested slot is too many for region.
    if (num_rank * threads_per_rank) / (regions_per_node * num_node) > cores_per_region:
        suggestion = ""
        if align != "node":
            suggestion = '. Maybe you want "--align=node"?'
        eexit(1, f"{num_rank} ranks with {threads_per_rank} threads are too many "
                +f"for {align} ({cores_per_region} cores per {align}){suggestion}")
    # Check if requested slot cannot be splitted to region equally
    if (num_rank * threads_per_rank / num_node) % regions_per_node != 0:
        suggestion = ""
        if align != "node":
            suggestion = '. Maybe you want "--align=node"?'
        eexit(1, f"{num_rank} ranks with {threads_per_rank} threads cannot be "
                +f"split to {align} equally ({cores_per_region} cores per {align}){suggestion}")

    nranks = len(ranks)
    for i in range(nranks):
        rank = ranks[i]
        global_slot_start = i * threads_per_rank
        region_index = (global_slot_start // slots_per_region) % regions_per_node # which region in node
        slot_start_index = region_index * cores_per_region + (i % ranks_per_region) * threads_per_rank
        slot_stop_index = slot_start_index + threads_per_rank - 1
        if not left_most_cores:
            offset = cores_per_region - slots_per_region
            slot_start_index = offset + slot_start_index
            slot_stop_index = offset + slot_stop_index
        rank.slots = [i for i in range(slot_start_index, slot_stop_index+1)]
        rank.node_format = hwinfo.name_format
        rank.node_index = first_node_index + (global_slot_start // slots_per_node) # which node
        if rank.node_index < first_node_index or rank.node_index > last_node_index:
            eexit(1, f'rank {i} is out of range for node index range [{first_node_index}, {last_node_index}]')



def main():
    global QUIET
    terminal_width = shutil.get_terminal_size((80, 20))[0]
    parser = argparse.ArgumentParser(
        prog='rankgen',
        description=f'Genrate rankfile or command line arguments by specified distribution (version {VERSION})\n',
        epilog='Example: %(prog)s --finger=all --name="bn{:03d}" --last=108 2 24 10',
        add_help=False,
        usage='%(prog)s [OPTIONS] <num_node> <num_rank> <threads_per_rank>',
        formatter_class=lambda prog: argparse.ArgumentDefaultsHelpFormatter(prog, max_help_position=terminal_width)
    )
    parser.add_argument('num_node', type=int, help=f"Number of node to use")
    parser.add_argument('num_rank', type=int, help=f"Number of ranks")
    parser.add_argument('threads_per_rank', type=int, default=1, help=f"Number of threads per rank")
    # metavar='' for removing dest variable from help text
    hwinfoArgs = parser.add_argument_group('Hardware information arguments')
    hwinfoArgs.add_argument('--name', dest='name', default="cn{:03d}", type=str, help=f"Node name format in python formatting syntax", metavar='')
    hwinfoArgs.add_argument('--first', dest='first', action=RecorderAction, default=101, type=int, help="Inclusive node start index", metavar='')
    hwinfoArgs.add_argument('--last', dest='last', action=RecorderAction, type=int, help="Inclusive node end index", metavar='')
    hwinfoArgs.add_argument('--sockets-per-node', dest='sockets_per_node', default=2, type=int, help=f"Sockets per node", metavar='')
    hwinfoArgs.add_argument('--numas-per-socket', dest='numas_per_socket', default=2, type=int, help=f"NUMAs per socket", metavar='')
    hwinfoArgs.add_argument('--cores-per-numa', dest='cores_per_numa', default=32, type=int, help=f"Cores per numa", metavar='')
    # hwinfoArgs.add_argument('--hwthreads-per-core', dest='hwthreads_per_core', default=1, type=int, help=f"HWThreads per core", metavar='')
    generatorArgs = parser.add_argument_group('generator arguments')
    generatorArgs.add_argument('-o', dest='outfile', default="<stdout>", type=str, help=f"Write output to file", metavar='')
    generatorArgs.add_argument('-t', '--temp', dest='use_tempfile', action='store_const', const=True, default=False, help="Write output to temp file and print filename", metavar='')
    generatorArgs.set_defaults(left_most_cores=False)
    generatorArgs.set_defaults(no_fingerprint=False)
    generatorArgs.add_argument('--align', dest='align', default='numa', choices=['numa', 'socket', 'node'], help="Align ranks to the numa/socket/node region", metavar='')
    # generatorArgs.add_argument('--imbalance', dest='imbalance', action='store_const', const=True, default=False, help="Allow imbalancing over regions", metavar='')
    generatorArgs.add_argument('--left', dest='left_most_cores', action='store_const', const=True, help="Use left-most cores of the region", metavar='')
    generatorArgs.add_argument('--finger', dest='fingerprint', default="first", choices=['first', 'all', 'no'], help="Display first/all/no fingerprint of node", metavar='')
    parser.add_argument('-q', '--quiet', dest='quiet', action='store_const', const=True, default=False, help="Don't print information", metavar='')
    parser.add_argument('-v', '--version', action='version', version=f'{VERSION}', help="Show version number and exit")
    parser.add_argument('-h', '--help', action='help', help=f"Show this help message and exit")

    args = parser.parse_args()
    num_node = args.num_node
    num_rank = args.num_rank
    threads_per_rank = args.threads_per_rank
    hwinfo = HardwareInfo(args.name, args.sockets_per_node, args.numas_per_socket, args.cores_per_numa, 1)
    outfile = args.outfile
    use_tempfile = args.use_tempfile
    left_most_cores = args.left_most_cores
    align = args.align
    # allow_unbalance = args.allow_unbalance
    fingerprint = args.fingerprint
    QUIET = args.quiet

    if "--last" not in RecorderAction.named_record:
        first_node_index = args.first
        last_node_index = first_node_index + num_node - 1
    else: #"--last" in RecorderAction.named_record
        if "--first" not in RecorderAction.named_record:
            last_node_index = args.last
            first_node_index = last_node_index - num_node + 1
        else: #"--first" in RecorderAction.named_record
            first_node_index = args.first
            last_node_index = args.last

    ranks_per_node = num_rank // num_node
    nranks = ranks_per_node * num_node
    ranks = [Rank(i) for i in range(nranks)]

    aligned_fill(ranks, hwinfo, align, left_most_cores,
                 num_rank, first_node_index, last_node_index,
                 ranks_per_node, threads_per_rank, num_node)

    eprint(f"{parser.prog}: {parser.description}")
    eprint(f"=== Node Information")
    eprint(f"name prefix: {hwinfo.name_format}")
    eprint(f"sockets per node: {hwinfo.sockets_per_node}")
    eprint(f"numas per node: {hwinfo.numas_per_node}")
    eprint(f"cores per node: {hwinfo.cores_per_node}")
    eprint(f"")
    eprint(f"=== Generator Information")
    eprint(f"Number of node: {num_node}")
    eprint(f"Number of rank (per node): {ranks_per_node}")
    eprint(f"Number of thread (per rank): {threads_per_rank}")
    eprint(f"Output to {outfile}")
    eprint(f"")

    content = "\n".join([str(rank) for rank in ranks])
    if use_tempfile:
        with tempfile.NamedTemporaryFile(mode="w", delete=True) as tmp:
            tmp.write(content)
            print(tmp.name)
    elif outfile == "<stdout>":
        eprint(f"=== Content generated to <stdout>:")
        print(content)
        eprint(f"")
    else:
        pathlib.Path(outfile).parent.mkdir(parents=True, exist_ok=True)
        with open(outfile, "w") as f:
            f.write(content)
    if fingerprint == "first":
        eprint(f"=== Fingerprint of first node")
        print_fingerprint(hwinfo, ranks, align, first_node_index)
    elif fingerprint == "all":
        eprint(f"=== Fingerprint of all {num_node} nodes")
        for i in range(first_node_index, last_node_index+1):
            print_fingerprint(hwinfo, ranks, align, i)

if __name__ == '__main__':
    main()
